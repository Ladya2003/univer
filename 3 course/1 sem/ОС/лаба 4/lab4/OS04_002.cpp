#include <Windows.h>
#include <iostream>
#include "os04_02.h"

DWORD pid = NULL;
using namespace std;

DWORD WINAPI ChildThread() {
	DWORD tid = GetCurrentThreadId();
	for (int i = 0; i < 50; i++)
	{
		cout << i << " " << "OS04_02_T1: " << "PID: " << pid << " " << "TID: " << tid << ";" << endl;
	    Sleep(1000);
	}

	return 0;
}

DWORD WINAPI ChildSecondThread() {
	DWORD tid = GetCurrentThreadId();
	for (int i = 0; i < 125; i++)
	{
		cout << i << " " << "OS04_02_T2: " << "PID: " << pid << " " << "TID: " << tid << ";" << endl;
		Sleep(1000);
	}

	return 0;
}



int main()
{	
	pid = GetCurrentProcessId();
	DWORD tid = GetCurrentThreadId();
	DWORD childId = NULL;
	DWORD childSecondId = NULL; 
	
	HANDLE hChild = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)ChildThread, NULL, 0, &childId);
	HANDLE hChildSecond = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)ChildSecondThread, NULL, 0, &childSecondId);

	for (int i = 0; i < 100; i++)
	{
        cout << i << " " << "Parent Thread: " << "PID: " << pid << " " << "TID: " << tid << ";" << endl;
		Sleep(1000);
	}

	WaitForSingleObject(hChild, INFINITE);
	CloseHandle(hChild);

}





// сначала выполняется main потом он ставится в sleep и выполняется один из дочерних, потом он в sleep и второй дочерний

// GetCurrentProcessId возвращает идентификатор текущего процесса

// WINAPI - ChildThread может быть передана в функции создания потоков Windows API, такие как CreateThread, и, 
// следовательно, ей нужно использовать ту же конвенцию вызова, что и ожидаемая функция.
// Таким образом, WINAPI (или __stdcall) гарантирует, что функция примет аргументы правильным образом и будет 
// совместима с Windows API.

// конвенция вызова stdcall: Эта конвенция вызова часто используется в Windows API. Как и в cdecl, 
// аргументы передаются через стек, но функция очищает стек перед возвратом, а не вызывающая сторона.

// HANDLE hChild = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)ChildThread, NULL, 0, &childId);

// NULL (Первый аргумент) — это атрибут безопасности. Указание NULL означает, что у дескриптора потока будет 
//дескриптор безопасности по умолчанию и дочерний процесс не будет наследовать этот дескриптор.

// 0 (Второй аргумент) — это размер стека для нового потока.Если вы укажете 0, поток будет использовать размер стека 
// по умолчанию. позволяет вам определить, как много памяти будет выделено под стек этого потока.

// (LPTHREAD_START_ROUTINE)ChildThread(Третий аргумент) — это указатель на функцию, которая будет выполняться в 
// новом потоке.В вашем случае это функция ChildThread.

// NULL(Четвертый аргумент) — это аргумент, который будет передан в вашу функцию ChildThread.Так как у вас нет 
// аргументов для этой функции, вы передаете NULL.

// 0 (Пятый аргумент) — это флаги создания.Значение 0 означает, что поток запускается сразу после создания.

// & childId(Шестой аргумент) — это указатель на переменную, в которой будет храниться идентификатор потока.
// В вашем случае это childId.


// (LPTHREAD_START_ROUTINE) -  "Я уверен, что передаваемая функция соответствует ожидаемой сигнатуре, даже если 
// она не выглядит так". (сигнатура функции createthread)

// 5 аргумент:
// 0: Поток запускается сразу после создания.

// CREATE_SUSPENDED : Поток создается в приостановленном состоянии.Это означает, что поток не начнет выполнение, пока вы явно не возобновите его с помощью функции ResumeThread.

// STACK_SIZE_PARAM_IS_A_RESERVATION : Этот флаг указывает, что второй параметр(размер стека) определяет общий размер резервируемой памяти, а не начальный фактический размер стека.Если этот флаг не указан, размер стека определяет начальный фактический размер стека, и операционная система может увеличивать его при необходимости до максимального резервируемого размера, который определен в исполняемом файле вашего приложения.

// Таким образом, строка WaitForSingleObject(hChild, INFINITE); гарантирует, что главный поток (main) будет ждать завершения работы дочернего потока ChildThread перед тем, как завершить свою работу. Если бы этой строки не было, главный поток мог бы завершить свою работу, не дождавшись завершения дочерних потоков.